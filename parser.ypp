%{
#include "source.hpp"
#include "hw3_output.hpp"
#include <iostream>
#include <stdlib.h>
#include "table_stack.hpp"
using namespace std;
extern int yylex();
void yyerror(const char*);
extern TableStack table_stack;
%}

%nonassoc STRING;
%nonassoc VOID;
%nonassoc INT;
%nonassoc BYTE;
%nonassoc BOOL;
%nonassoc B;
%nonassoc TRUE;
%nonassoc FALSE;
%nonassoc RETURN;
%nonassoc WHILE;
%nonassoc BREAK;
%nonassoc CONTINUE;
%nonassoc SC;
%nonassoc COMMA;
%nonassoc RBRACE;
%nonassoc LBRACE;
%nonassoc OVERRIDE;
%nonassoc NUM;
%nonassoc ID;

%right ASSIGN;

%left OR;
%left AND;
%left EQLOP;
%left RELOP;
%left ADD;
%left MUL;

%right NOT;

%left RPAREN;
%left LPAREN;

%right IF;
%right ELSE;

%%

Program:        M Funcs                                                             {output::printProductionRule(1);};
Funcs:          epsilon                                                             {output::printProductionRule(2);}
                | FuncDecl Funcs                                                    {output::printProductionRule(3);}
;

M: epsilon                                                                           {table_stack.openNewScope();};
X: OverRide RetType ID LPAREN Formals                                                {table_stack.addFuncSymbol($3->getType(), $2->getType(), $5->getType(), $1->getType());};
FuncDecl:  X RPAREN LBRACE M Statements RBRACE                                      {output::printProductionRule(4);
                                                                                     table_stack.closeScope();}
;
OverRide:       epsilon                                                             {output::printProductionRule(5);
                                                                                     $$ = new Node();}
                | OVERRIDE                                                          {output::printProductionRule(6);
                                                                                     $$ = new Node("OVERRIDE");}
;
RetType:        Type                                                                {output::printProductionRule(7);
                                                                                     $$ = $1;}
                | VOID                                                              {output::printProductionRule(8);
                                                                                     $$ = $1;}
;
Formals:        epsilon                                                             {output::printProductionRule(9);
                                                                                     $$ = new FormalList();}
                | FormalsList                                                       {output::printProductionRule(10);
                                                                                      $$ = new FormalList(*$1);}
;
FormalsList:    FormalDecl                                                          {output::printProductionRule(11);
                                                                                     $$ = new FormalList(*$1);}
                | FormalDecl COMMA FormalsList                                      {output::printProductionRule(12);
                                                                                      $$ = new FormalList(*$1, *$3);}
;
FormalDecl:     Type ID                                                             {output::printProductionRule(13);
                                                                                     table_stack.addSymbolToLastTable($2->getType(), $1->getType());}
;
Statements:     Statement                                                           {output::printProductionRule(14);}
                | Statements Statement                                              {output::printProductionRule(15);}
;
Statement:      LBRACE M Statements RBRACE                                            {output::printProductionRule(16);
                                                                                       table_stack.closeScope();};
                | Type ID SC                                                        {output::printProductionRule(17);}
                | Type ID ASSIGN Exp SC                                             {output::printProductionRule(18);
                                                                                    table_stack.addSymbolToLastTable($2->getType(), $1->getType());}
                | ID ASSIGN Exp SC                                                  {output::printProductionRule(19);}
                                                                                     // compare id.type and exp.type}
                | Call SC                                                           {output::printProductionRule(20);}
                | RETURN SC                                                         {output::printProductionRule(21);}
                | RETURN Exp SC                                                     {output::printProductionRule(22);}
                | IF LPAREN Exp RPAREN Statement                                    {output::printProductionRule(23);}
                | IF LPAREN Exp RPAREN Statement ELSE Statement                     {output::printProductionRule(24);}
                | WHILE LPAREN Exp RPAREN Statement                                 {output::printProductionRule(25);}
                | BREAK SC                                                          {output::printProductionRule(26);}
                | CONTINUE SC                                                       {output::printProductionRule(27);}
;
Call:           ID LPAREN ExpList RPAREN                                            {output::printProductionRule(28);
                                                                                     $$ = new Call(*$1, $3);}
                | ID LPAREN RPAREN                                                  {output::printProductionRule(29);
                                                                                     $$ = new Call(*$1);}
;
ExpList:        Exp                                                                 {output::printProductionRule(30);
                                                                                     $$ = new ExpList(*$1);}
                | Exp COMMA ExpList                                                 {output::printProductionRule(31);
                                                                                     $$ = new ExpList(*$1, $3);}
;
Type:           INT                                                                 {output::printProductionRule(32);
                                                                                     $$ = $1;}
                | BYTE                                                              {output::printProductionRule(33);
                                                                                     $$ = $1;}
                | BOOL                                                              {output::printProductionRule(34);
                                                                                     $$ = $1;}
;
Exp:            LPAREN Exp RPAREN                                                   {output::printProductionRule(35);
                                                                                     $$ = $2;}
                | Exp ADD Exp                                                       {output::printProductionRule(36);
                                                                                     $$ = new Exp(*$1, "binop",  *$3);}
                | Exp MUL Exp                                                       {output::printProductionRule(36);
                                                                                     $$ = new Exp(*$1, "binop", *$3);}
                | ID                                                                {output::printProductionRule(37);
                                                                                     $$ = new Exp(*$1, "id");}
                | Call                                                              {output::printProductionRule(38);
                                                                                     $$ = new Exp(*$1, "call");}
                | NUM                                                               {output::printProductionRule(39);
                                                                                      $$ = new Exp("INT");}
                | NUM B                                                             {output::printProductionRule(40);
                                                                                     $$ = new Exp(*$1);}
                | STRING                                                            {output::printProductionRule(41);
                                                                                     $$ = new Exp("STRING");}
                | TRUE                                                              {output::printProductionRule(42);
                                                                                     $$ = new Exp("BOOL");}
                | FALSE                                                             {output::printProductionRule(43);
                                                                                     $$ = new Exp("BOOL");}
                | NOT Exp                                                           {output::printProductionRule(44);
                                                                                     $$ = new Exp(*$2, "not");}
                | Exp AND Exp                                                       {output::printProductionRule(45);
                                                                                     $$ = new Exp(*$1, "bool_op", *$3);}
                | Exp OR Exp                                                        {output::printProductionRule(46);
                                                                                     $$ = new Exp(*$1, "bool_op", *$3);}
                | Exp RELOP Exp                                                     {output::printProductionRule(47);
                                                                                     $$ = new Exp(*$1, "relop",  *$3);}
                | Exp EQLOP Exp                                                     {output::printProductionRule(47);
                                                                                     $$ = new Exp(*$1, "relop", *$3);}
                | LPAREN Type RPAREN Exp                                            {output::printProductionRule(48);
                                                                                     $$ = new Exp(*$4, $2->getType());}
;
epsilon:        %empty;

%%
 //i AM SHAKED
void yyerror(const char * message)
{
    output::errorSyn(yylineno);
    exit(0);
}

int main()
{
	return yyparse();
}